# Оптимизация размера сборки

Этот документ описывает оптимизации, примененные для уменьшения количества DLL и размера релизной сборки.

## Проблема

В релизной сборке присутствовало большое количество DLL (27+ файлов) и множество runtime директорий для неиспользуемых платформ (linux-x64, osx-x64, win-x86), при этом:
- `Microsoft.Windows.SDK.NET.dll` занимал >25 МБ
- Присутствовали DLL для всех платформ
- Включались неиспользуемые транзитивные зависимости (Xceed.Wpf.AvalonDock)

## Применённые оптимизации

### 1. RuntimeIdentifier для win-x64

**Изменение в AssetProcessor.csproj:**
```xml
<RuntimeIdentifier>win-x64</RuntimeIdentifier>
```

**Эффект:**
- Удаляет runtime директории для linux-x64, osx-x64, win-x86
- Включает в сборку только нативные библиотеки для Windows x64 (assimp.dll, ktx.dll)
- Уменьшает общий размер дистрибутива

### 2. Отключение отладочной информации

**Изменения в AssetProcessor.csproj:**
```xml
<StripSymbols>true</StripSymbols>
<DebugType>none</DebugType>
<DebugSymbols>false</DebugSymbols>
<DebuggerSupport>false</DebuggerSupport>
```

**Эффект:**
- Удаляет отладочные символы из Release сборки
- Удаляет метаданные отладчика
- Уменьшает размер исполняемых файлов

### 3. Оптимизация компиляции

**Изменения в AssetProcessor.csproj:**
```xml
<Optimize>true</Optimize>
<EnableUnsafeBinaryFormatterSerialization>false</EnableUnsafeBinaryFormatterSerialization>
```

**Эффект:**
- Включает оптимизации компилятора для Release сборки
- Отключает небезопасную сериализацию (улучшение безопасности)
- Улучшает производительность и может уменьшить размер кода

### 4. Почему НЕ используется Trimming

⚠️ **ВАЖНО:** WPF **официально не поддерживает** trimming (PublishTrimmed) в .NET 9.

При попытке использовать `<PublishTrimmed>true</PublishTrimmed>` возникает ошибка:
```
error NETSDK1168: WPF не поддерживается и не рекомендуется использовать с включенной обрезкой.
```

Подробнее: https://aka.ms/dotnet-illink/wpf

**Причины:**
- WPF активно использует рефлексию для XAML
- XAML парсер создает объекты динамически
- Data binding полагается на рефлексию
- Trimmer не может статически определить, какой код используется

**Альтернативы:**
- Для консольных или ASP.NET приложений trimming работает отлично
- Для WPF приложений нужно использовать другие методы оптимизации (RuntimeIdentifier, удаление неиспользуемых зависимостей)

## Ограничения и компромиссы

### Microsoft.Windows.SDK.NET.dll

Эту библиотеку **нельзя полностью удалить**, так как она является core-зависимостью для WPF приложений на .NET 9.

**Текущая ситуация:**
- Размер: >25 МБ
- Содержит проекции для всех Windows API
- Необходима для WPF и Windows-специфичной функциональности

**Возможные подходы к уменьшению размера:**

1. **Использование более старой версии Windows SDK** - может уменьшить размер
   ```xml
   <TargetFramework>net9.0-windows10.0.19041.0</TargetFramework>
   ```
   ⚠️ Компромисс: потеряется доступ к новым Windows 11 API, но уменьшится размер SDK библиотеки

2. **Self-contained публикация** - включит .NET runtime в дистрибутив
   ```xml
   <SelfContained>true</SelfContained>
   ```
   ⚠️ Компромисс: дистрибутив станет значительно больше (~150+ МБ), но приложение будет работать без установленного .NET runtime

3. **Ручное удаление неиспользуемых DLL после сборки**
   - Требует тщательного тестирования
   - Может привести к runtime ошибкам
   - ⚠️ Не рекомендуется для production

**Рекомендация:**
Оставить как есть. Microsoft.Windows.SDK.NET.dll необходима для современных WPF приложений, и её размер - это компромисс за доступ к полному Windows API.

### Транзитивные зависимости

**Xceed.Wpf.AvalonDock** и его темы (Aero, Metro, VS2010) являются транзитивными зависимостями от `Extended.Wpf.Toolkit` и **не используются** в проекте напрямую.

**Текущая ситуация:**
- AvalonDock DLL включаются в сборку из-за транзитивной зависимости
- Попытки явно исключить их через `ExcludeAssets="all"` могут сломать `Extended.Wpf.Toolkit`
- Общий размер AvalonDock библиотек: ~2-3 МБ

**Возможные решения:**
1. **Заменить Extended.Wpf.Toolkit** на альтернативную библиотеку без AvalonDock зависимости
2. **Использовать только нужные контролы** - скопировать исходники нужных контролов в проект
3. **Оставить как есть** - размер не критичный для desktop приложения

**Рекомендация:**
Оставить как есть, так как замена Extended.Wpf.Toolkit потребует значительного рефакторинга UI.

### Другие зависимости

Все остальные зависимости **активно используются** в проекте:

- **AssimpNet** - загрузка 3D моделей (MainWindow.xaml.cs)
- **HelixToolkit.Wpf** - отображение 3D моделей (MainWindow.xaml.cs, MainWindowHelpers.cs)
- **SixLabors.ImageSharp** - обработка изображений (вся texture conversion pipeline)
- **Vortice.\*** (D3DCompiler, Direct3D11, DXGI) - TextureViewer с GPU рендерингом
- **OxyPlot.Wpf** - построение графиков и диаграмм
- **Newtonsoft.Json** - работа с PlayCanvas API
- **NLog** - логирование
- **CommunityToolkit.Mvvm** - MVVM helpers
- **Microsoft.Xaml.Behaviors.Wpf** - WPF behaviors
- **Ookii.Dialogs.Wpf** - нативные диалоги Windows

Все эти библиотеки необходимы и не могут быть удалены.

### Нативные библиотеки

**ktx.dll** - нативная библиотека для работы с KTX2 форматом (P/Invoke в TextureViewer/LibKtxNative.cs). Необходима для TextureViewer функциональности.

**assimp.dll** - нативная библиотека для загрузки 3D моделей. Необходима для AssimpNet.

Обе библиотеки теперь включаются только для win-x64 платформы.

## Результаты

После применения оптимизаций:

1. ✅ Удалены runtime директории для неиспользуемых платформ (linux-x64, osx-x64, win-x86)
2. ✅ Удалена отладочная информация из Release сборки
3. ✅ Включены оптимизации компилятора
4. ✅ Отключена небезопасная сериализация
5. ✅ Все зависимости проверены на использование

**Ожидаемый результат:**
- Уменьшение количества файлов в папке runtimes (только win-x64)
- Уменьшение размера исполняемых файлов за счет удаления debug символов
- Улучшение производительности за счет оптимизаций компилятора

**Что НЕ изменилось:**
- Количество managed DLL остается прежним (trimming не поддерживается для WPF)
- Microsoft.Windows.SDK.NET.dll остается ~25 МБ (необходима для WPF)
- Транзитивные зависимости (AvalonDock) остаются в сборке

### Команды для сборки

**Release сборка с оптимизациями:**
```bash
dotnet build AssetProcessor.csproj --configuration Release
```

**Публикация (для single-file executable):**
```bash
dotnet publish AssetProcessor.csproj --configuration Release --runtime win-x64 --self-contained false
```

**Публикация с самостоятельной сборкой (включает .NET runtime):**
```bash
dotnet publish AssetProcessor.csproj --configuration Release --runtime win-x64 --self-contained true
```

⚠️ **Внимание:** Self-contained сборка будет значительно больше (~150+ МБ), так как включает весь .NET runtime. Используйте `--self-contained false` для зависимости от установленного .NET 9 runtime на целевой системе.

## Дальнейшие оптимизации (опциональные)

### 1. Миграция с Newtonsoft.Json на System.Text.Json

System.Text.Json является частью .NET runtime и может уменьшить количество зависимостей.

**Плюсы:**
- Убирает Newtonsoft.Json DLL (~700 КБ)
- Лучшая производительность
- Встроена в .NET runtime

**Минусы:**
- Требует переписывания всего кода работы с JSON
- API отличается от Newtonsoft.Json
- Может потребовать изменения логики (десериализация работает по-другому)

### 2. Использование более лёгких UI библиотек

Рассмотреть замену Extended.Wpf.Toolkit на более лёгкие альтернативы или копирование только нужных контролов в проект.

**Плюсы:**
- Убирает транзитивные зависимости (Xceed.Wpf.AvalonDock)
- Уменьшение размера на ~5-7 МБ

**Минусы:**
- Требует значительного рефакторинга UI
- Поддержка и обновление контролов ложится на проект
- Может потребоваться переделка XAML

### 3. Оптимизация ресурсов

**Сжатие изображений и ресурсов:**
- Конвертация PNG в оптимизированные форматы
- Использование WebP для изображений (если поддерживается)
- Сжатие встроенных ресурсов

### 4. Использование более старой Windows SDK

```xml
<TargetFramework>net9.0-windows10.0.19041.0</TargetFramework>
```

**Плюсы:**
- Уменьшение размера Microsoft.Windows.SDK.NET.dll

**Минусы:**
- Потеря доступа к новым Windows 11 API
- Возможные проблемы совместимости

### Что НЕ работает для WPF

❌ **PublishTrimmed** - официально не поддерживается (ошибка NETSDK1168)
❌ **NativeAOT** - WPF не совместим с NativeAOT из-за рефлексии и XAML
❌ **Агрессивное удаление DLL** - может сломать runtime

## Анализ размера сборки

Для анализа размера после сборки:

```bash
# В PowerShell
Get-ChildItem -Path "bin\Release\net9.0-windows10.0.26100.0\win-x64" -Recurse -File |
  Select-Object Name, @{Name="Size(MB)";Expression={[math]::Round($_.Length/1MB,2)}} |
  Sort-Object -Property "Size(MB)" -Descending

# Общий размер
Get-ChildItem -Path "bin\Release\net9.0-windows10.0.26100.0\win-x64" -Recurse -File |
  Measure-Object -Property Length -Sum |
  Select-Object @{Name="TotalSize(MB)";Expression={[math]::Round($_.Sum/1MB,2)}}
```

Это покажет все файлы отсортированные по размеру и общий размер дистрибутива.

## Заключение

Применённые оптимизации уменьшают размер дистрибутива без потери функциональности:
- ✅ Удалены runtimes для неиспользуемых платформ (уменьшение размера папки runtimes)
- ✅ Удалены debug символы (уменьшение размера EXE/DLL)
- ✅ Включены оптимизации компилятора (улучшение производительности)

**Важное ограничение:**
WPF **не поддерживает** trimming и NativeAOT в .NET 9. Это означает, что количество managed DLL останется прежним (~27 файлов), и Microsoft.Windows.SDK.NET.dll останется ~25 МБ.

**Дальнейшее уменьшение размера:**
Требует существенных архитектурных изменений:
- Миграция на System.Text.Json вместо Newtonsoft.Json
- Замена Extended.Wpf.Toolkit на более лёгкие альтернативы
- Использование более старой Windows SDK версии
- Ручная оптимизация ресурсов

Все эти изменения требуют значительного рефакторинга и тестирования.

**Рекомендация:**
Текущие оптимизации достаточны для desktop WPF приложения. Периодически проверяйте размер сборки и анализируйте новые зависимости перед их добавлением в проект.
