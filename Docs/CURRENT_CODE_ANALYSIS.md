# Текущий анализ кодовой базы PlaycanvasAssetProcessor

Дата анализа: 2026-02-07

## 1) Общий профиль проекта

- Приложение — desktop WPF (`net9.0-windows10.0.26100.0`) с выраженной сервисной архитектурой и DI через `Microsoft.Extensions.DependencyInjection`.
- В проекте заметный объём UI-кода и большой объём доменной логики обработки текстур/моделей.
- По быстрой метрике размера: ~304 файлов релевантных типов (`.cs`, `.xaml`, `.md`, `.csproj`, `.sln`) и ~80k строк.

## 2) Архитектура: что уже хорошо

1. **Есть формализованные архитектурные правила** (`MVVM + Service Layer`), отдельно описаны ограничения по слоям, паттерны и DI-подход.
2. **DI-композиция централизована в `App.xaml.cs`**: сервисы, координирующие компоненты и ViewModel регистрируются единообразно.
3. **Наличие выделенного test-проекта** (`AssetProcessor.Tests`) и широкой сетки unit-тестов по сервисам/VM.
4. **Сфокусированные доменные подсистемы**:
   - `TextureConversion/*` (pipeline, mip/toksvig, KTX/BasisU)
   - `ModelConversion/*` (конвертация, LOD, анализ)
   - `TextureViewer/*` (D3D11 preview)

## 3) Ключевые технические риски

### 3.1. Перегрузка `MainWindow` (скрытый «god object»)

- `MainWindow` разбит на множество partial-файлов (19+), но по факту остаётся центральным монолитом управления.
- Есть крупные файлы code-behind (`MainWindow.Models.cs`, `MainWindow.GlbLod.cs`, `MainWindow.TextureViewerUI.cs` и др.), что усложняет безопасный рефакторинг.
- Конструктор `MainWindow` принимает большой набор сервисов, что указывает на высокую связность и размытые границы ответственности.

**Эффект:** рост стоимости изменений, высокий риск регрессий при доработке UI/оркестрации.

### 3.2. Смешение UI-событий и бизнес-оркестрации

- Зафиксировано значительное число `async void` обработчиков по всему UI-слою (в т.ч. в `MainWindow.*`, `Controls/*`, `SettingsWindow`).
- Для event-handler в WPF это допустимо, но в таком объёме усложняет контроль ошибок, отмену операций и трассировку.

**Эффект:** нестабильность в edge-case сценариях, сложность воспроизведения race-condition.

### 3.3. Сложность сопровождения больших XAML/CS файлов

- `MainWindow.xaml` и ряд CS-файлов имеют очень большой размер (1000+ строк), что увеличивает когнитивную нагрузку команды.

**Эффект:** замедление code review и повышенный порог входа новых разработчиков.

### 3.4. Точечные индикаторы незавершённости

- В коде обнаружены TODO в критичных цепочках (например, пост-обработка UV в `GltfPackWrapper`, параметризация toksvig в batch processing).

**Эффект:** функциональные ограничения остаются «внутри» production-кода без явной дорожной карты закрытия.

## 4) Приоритетный план улучшений (практический)

### P1 — декомпозиция UI-оркестрации

- Вытащить из `MainWindow` отдельные coordinator-компоненты по вертикалям:
  - Connection/Project lifecycle
  - Texture conversion workflow
  - Model import/export workflow
  - Viewer state & preview rendering
- Цель: сократить ответственность каждого partial-файла и упростить unit-тестирование поведения.

### P2 — ужесточить асинхронный контракт

- Оставить `async void` только в чистых event-handler.
- Вынести тяжёлую логику в `Task`-методы сервисов/VM с явной обработкой ошибок и `CancellationToken`.
- Добавить единый policy логирования исключений для асинхронных команд UI.

### P3 — модульность View

- Разбить `MainWindow.xaml` на composable UserControl-блоки по bounded-context (Assets, Materials, Texture Preview, Model Preview, ORM).
- Часть code-behind перенести в команды VM + attachable behaviors.

### P4 — техдолг и наблюдаемость

- Завести явный backlog по найденным TODO (issue/roadmap с сроками).
- Для тяжёлых pipeline-операций добавить telemetry-события длительности и причин отказа.

## 5) Итог

Проект уже имеет крепкий фундамент (архитектурные правила, DI, выделенные сервисные слои, тестовый контур), но упирается в масштаб монолитного `MainWindow` и связанную с ним стоимость изменений. Главная точка роста — дальнейшая декомпозиция UI-оркестрации и дисциплина асинхронных сценариев.
